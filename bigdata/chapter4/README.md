## ndarray.py
+ Ndarray
+ 같은 종류의 데이터를 저장하는 포괄적 다차원 배열
+ shape : 차원을 알려주는 튜플
+ dtype : 배열에 저장된 자료형
+ ndim : 배열의 차원

## make_ndarray.py
+ array를 이용한 생성
+ 적절한 자료형을 추정
+ np.zeros(10) : 1x10 0 배열생성
+ np.zeros((3,6)) : 3x6 0 배열생성
+ np.empty((2,3,2)) : 2x3x2 garbage 배열생성
+ np.arrange(15) : range()의 np 버전

## scalar_numpy.py (배열과 스칼라 간의 연산)
+ 벡터화 : 배열은 for문을 작성하지 않고 데이터를 일괄처리할 수 있게 만드는 것
+ 같은 크기의 배열 간 산술연산은 배열의 각 요소 단위로 적용
- arr * arr 같은 경우는 같은 위치에 있는 요소까리의 곱셈을 이야기 함.
- 크기가 다른 배열간의 연산은 브로드캐스팅이라고 함
+ 스칼라 값에 대한 산술연산은 각 요소에 전달된다.

## slice_numpy.py
+ 1차원 : 리스트의 슬라이싱과 유사
+ 슬라이스는 원본의 뷰:
-> 데이터가 복사되지 않고 원본에 그대로 반영(리스트와 다름)
+ 복사본을 얻고 싶다면 np.copy()를 이용한다  (ex:  arr[5,8].copy())

## arr.py
+ 배열 개별요소는 재귀적 접근, 편의상 콤마(,)로 구분하여 접근 허용
+ 배열의 색인생략: 입력된 색인은 상위색인으로 해석

## recursive_numpy.py
+ 배열 개별 요소는 재귀적 접근, 편의상 콤마(,)로 구분하여 접근 허용
+ 배열의 (index)색인 생략 : 입력된 색인은 상위 색인으로 해석

## index_slicing_numpy.py (색인과 슬라이싱 기초)
+ 슬라이스 색인
+ 다차원 슬라이싱
+ 슬라이싱하면 항상 같은 차원에 배열에 대한 뷰를 얻게 됨
+ 정수 색인과 슬라이스를 함께 사용하면 한 차원 낮은 슬라이스를 얻게됨
+ 슬라이싱 구문에 값을 대입하면 선택 영역 전체에 값이 할당됨.

## boolean_index_numpy.py
+ boolean index
+ randn 함수를 이용하여 임의의 표준정규분포






